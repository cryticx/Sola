#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_GOOGLE_include_directive : require

#include "hostDeviceCommon.glsl"
#include "rayCommon.glsl"

hitAttributeEXT vec2 attribs;

layout(push_constant)					uniform _PushConstants		{ PushConstants pushConstants; };

layout(binding = uniHitBind, scalar)	uniform _RayHitUniform		{ RayHitUniform rayHitUniform; };
layout(binding = sampBind)				uniform sampler				texSampler;
layout(binding = texBind)				uniform texture2D			textures[maxTex];

layout(buffer_reference, scalar)		readonly buffer Indices		{ u16vec3	a[]; };
layout(buffer_reference, scalar)		readonly buffer Vertices	{ Vertex	a[]; };
layout(buffer_reference, scalar)		readonly buffer Materials	{ Material	a[]; };

void main() {
	const vec3			barycentrics	= vec3(1.f - attribs.x - attribs.y, attribs.x, attribs.y);

	const int			geometryIndex	= rayHitUniform.instanceOffsets[gl_InstanceID] + gl_GeometryIndexEXT;

	const u16vec3		indices			= Indices	(pushConstants.indexAddr	+	rayHitUniform.geometryOffsets[geometryIndex].index).a[gl_PrimitiveID];

	Vertices			pVertices		= Vertices	(pushConstants.vertexAddr	+	rayHitUniform.geometryOffsets[geometryIndex].vertex);

	const Material		mat				= Materials	(pushConstants.materialAddr).a[	rayHitUniform.geometryOffsets[geometryIndex].material];

	const Vertex		vertices[3]		= Vertex[3](pVertices.a[indices.x], pVertices.a[indices.y], pVertices.a[indices.z]);

	const vec2			texUV			= vertices[0].texUV * barycentrics.x + vertices[1].texUV * barycentrics.y + vertices[2].texUV * barycentrics.z;

	const vec4			colorTex		= texture(sampler2D(textures[mat.colorTexIdx], texSampler), texUV);

	if (colorTex.w < mat.alphaCutoff) //TODO implement blend-transparency w/ cull mask?
		ignoreIntersectionEXT;
}
