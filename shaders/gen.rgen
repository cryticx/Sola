#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include "hostDeviceCommon.glsl"
#include "rayCommon.glsl"

layout(location = 0)				rayPayloadEXT PrimaryPayload		payload;

layout(binding = asBind)			uniform accelerationStructureEXT	topLevelAS;
layout(binding = imgBind, rgba16f)	uniform image2D						image;
layout(binding = genBind)			uniform _RayGenUniform				{ RayGenUniform rayGenUniform; };

void main() {
	const vec2 pixelCenter	= vec2(gl_LaunchIDEXT.xy) + vec2(0.5f);
	const vec2 inUV			= pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	const vec2 d			= inUV * 2.f - 1.f;

	const vec4 origin		= rayGenUniform.viewInverse * vec4(0.f, 0.f, 0.f, 1.f);
	const vec4 target		= rayGenUniform.projInverse * vec4(d.x, d.y, 1.f, 1.f);
	const vec3 targetUnit	= normalize(target.xyz);
	const vec4 direction	= rayGenUniform.viewInverse * vec4(targetUnit, 0.f);

	payload.raySpreadAngle	= 2.f * targetUnit.z * rayGenUniform.projInverse[1][1] / gl_LaunchSizeEXT.y;
	payload.totalDistance	= 0.f;
	payload.attenuation		= vec3(1.f);

	traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT, 0xFF, 0, 0, 0, origin.xyz, clipNear, direction.xyz, clipFar, 0); // primary hit

	vec3 color				= payload.hitColor;

	uint8_t	reflectCount	= uint8_t(0);

	while (length(payload.attenuation) > 0.01f && reflectCount < uint8_t(3)) { // reflection TODO implement rough reflections
		const vec3	R			= reflect(direction.xyz, payload.worldNorm);

		const vec3	attenuation	= payload.attenuation;

		traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT, 0xFF, 0, 0, 0, payload.worldPos, 0.001f, R, clipFar, 0);

		color += payload.hitColor * attenuation;

		reflectCount++;
	}
	const vec3 mappedColor = color / (vec3(1.f) + color); // Reinhard tone-mapping

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mappedColor, 0.f));
}
